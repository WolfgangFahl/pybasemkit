{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pybasemkit API Documentation","text":""},{"location":"#basemkit.argparse_action","title":"<code>argparse_action</code>","text":"<p>Created on 2025-08-29</p> <p>@author: wf</p>"},{"location":"#basemkit.argparse_action.StoreDictKeyPair","title":"<code>StoreDictKeyPair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Custom argparse action to store key-value pairs as a dictionary.</p> <p>This class implements an argparse action to parse and store command-line arguments in the form of key-value pairs. The pairs should be separated by a comma and each key-value pair should be separated by an equals sign.</p> Example <p>--option key1=value1,key2=value2,key3=value3</p> Reference <p>https://stackoverflow.com/a/42355279/1497139</p> Source code in <code>basemkit/argparse_action.py</code> <pre><code>class StoreDictKeyPair(argparse.Action):\n    \"\"\"\n    Custom argparse action to store key-value pairs as a dictionary.\n\n    This class implements an argparse action to parse and store command-line\n    arguments in the form of key-value pairs. The pairs should be separated by\n    a comma and each key-value pair should be separated by an equals sign.\n\n    Example:\n        --option key1=value1,key2=value2,key3=value3\n\n    Reference:\n        https://stackoverflow.com/a/42355279/1497139\n    \"\"\"\n\n    def __call__(\n        self,\n        _parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str,\n        _option_string: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Parse key-value pairs and store them as a dictionary in the namespace.\n\n        Args:\n            parser (argparse.ArgumentParser): The argument parser object.\n            namespace (argparse.Namespace): The namespace to store the parsed values.\n            values (str): The string containing key-value pairs separated by commas.\n            option_string (Optional[str]): The option string, if provided.\n        \"\"\"\n        my_dict = {}\n        for kv in values.split(\",\"):\n            k, v = kv.split(\"=\")\n            my_dict[k] = v\n        setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#basemkit.argparse_action.StoreDictKeyPair.__call__","title":"<code>__call__(_parser, namespace, values, _option_string=None)</code>","text":"<p>Parse key-value pairs and store them as a dictionary in the namespace.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The argument parser object.</p> required <code>namespace</code> <code>Namespace</code> <p>The namespace to store the parsed values.</p> required <code>values</code> <code>str</code> <p>The string containing key-value pairs separated by commas.</p> required <code>option_string</code> <code>Optional[str]</code> <p>The option string, if provided.</p> required Source code in <code>basemkit/argparse_action.py</code> <pre><code>def __call__(\n    self,\n    _parser: argparse.ArgumentParser,\n    namespace: argparse.Namespace,\n    values: str,\n    _option_string: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Parse key-value pairs and store them as a dictionary in the namespace.\n\n    Args:\n        parser (argparse.ArgumentParser): The argument parser object.\n        namespace (argparse.Namespace): The namespace to store the parsed values.\n        values (str): The string containing key-value pairs separated by commas.\n        option_string (Optional[str]): The option string, if provided.\n    \"\"\"\n    my_dict = {}\n    for kv in values.split(\",\"):\n        k, v = kv.split(\"=\")\n        my_dict[k] = v\n    setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#basemkit.base_cmd","title":"<code>base_cmd</code>","text":"<p>Created on 2025-06-16</p> <p>Minimal reusable command line base class with standard options.</p> <p>@author: wf</p>"},{"location":"#basemkit.base_cmd.BaseCmd","title":"<code>BaseCmd</code>","text":"<p>Minimal reusable command line base class with standard options: --about, --debug, --force, --quiet, --verbose, --version.</p> <p>Intended to be subclassed by tools requiring consistent CLI behavior.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>class BaseCmd:\n    \"\"\"\n    Minimal reusable command line base class with standard options:\n    --about, --debug, --force, --quiet, --verbose, --version.\n\n    Intended to be subclassed by tools requiring consistent CLI behavior.\n    \"\"\"\n\n    def __init__(self, version: Any, description: Optional[str] = None):\n        \"\"\"\n        Initialize the BaseCmd instance.\n\n        Args:\n            version: An object with .name, .version, .description, and .doc_url attributes.\n            description (str): Optional CLI description. Defaults to version.description.\n        \"\"\"\n        self.version = version\n        self.description = description or self.version.description\n        name = getattr(self.version, \"name\", \"\")\n        version = getattr(self.version, \"version\", \"\")\n        updated = getattr(self.version, \"updated\", \"\")\n        self.version_msg = f\"{name} {version} {updated}\".strip()\n        self.program_version_message = self.version_msg\n        self.debug = False\n        self.quiet = False\n        self.verbose = False\n        self.force = False\n        self.parser = None\n        self.exit_code = 0\n        self.args = None\n\n    def add_arguments(self, parser: ArgumentParser):\n        \"\"\"\n        Add standard CLI arguments to the parser, sorted by long option name.\n\n        Args:\n            parser (ArgumentParser): The parser to add arguments to.\n        \"\"\"\n        parser.add_argument(\"-a\", \"--about\", action=\"store_true\", help=\"show version info and open documentation\")\n        parser.add_argument(\"-d\", \"--debug\", action=\"store_true\", help=\"enable debug output\")\n        parser.add_argument(\n            \"--debugLocalPath\", help=\"remote debug Server path mapping - localPath - path on machine where python runs\"\n        )\n        parser.add_argument(\"--debugPort\", type=int, default=5678, help=\"remote debug Port [default: %(default)s]\")\n        parser.add_argument(\n            \"--debugRemotePath\", help=\"remote debug Server path mapping - remotePath - path on debug server\"\n        )\n        parser.add_argument(\"--debugServer\", help=\"remote debug Server\")\n        parser.add_argument(\"-f\", \"--force\", action=\"store_true\", help=\"force overwrite or unsafe actions\")\n        parser.add_argument(\"-q\", \"--quiet\", action=\"store_true\", help=\"suppress all output\")\n        parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"increase output verbosity\")\n        parser.add_argument(\"-V\", \"--version\", action=\"version\", version=self.program_version_message)\n\n    def getArgParser(self, description: str, version_msg: str) -&gt; ArgumentParser:\n        \"\"\"\n        Compatibility layer for legacy camelCase contract.\n        Calls get_arg_parser with overridden description and version_msg.\n        \"\"\"\n        self.description = description\n        self.program_version_message = version_msg\n        parser = ArgumentParser(description=description, formatter_class=RawDescriptionHelpFormatter)\n        self.add_arguments(parser)\n        return parser\n\n    def get_arg_parser(self) -&gt; ArgumentParser:\n        \"\"\"\n        Create and configure the argument parser.\n\n        Returns:\n            ArgumentParser: The configured argument parser.\n        \"\"\"\n        parser = self.getArgParser(self.description, self.version_msg)\n        return parser\n\n    def parse_args(self, argv=None) -&gt; Namespace:\n        \"\"\"\n        Parse command line arguments.\n\n        Args:\n            argv (list): Optional list of command line arguments. Defaults to sys.argv.\n\n        Returns:\n            Namespace: Parsed argument values.\n        \"\"\"\n        if self.parser is None:\n            self.parser = self.get_arg_parser()\n        self.args = self.parser.parse_args(argv)\n        args = self.args\n        return args\n\n    def cmd_parse(self, argv: List[str]) -&gt; Namespace:\n        \"\"\"delegate method\"\"\"\n        args = self.parse_args(argv)\n        return args\n\n    def optional_debug(self, args: Namespace):\n        \"\"\"\n        Optionally start pydevd remote debugging if debugServer is specified.\n\n        see https://www.pydev.org/manual_adv_remote_debugger.html\n\n        Args:\n            args (Namespace): Parsed CLI arguments\n        \"\"\"\n        if args.debugServer:\n            import pydevd\n            import pydevd_file_utils\n\n            remote_path = args.debugRemotePath\n            local_path = args.debugLocalPath\n\n            # note the complexity of https://stackoverflow.com/a/41765551/1497139\n            # discussed in 2011\n            if remote_path and local_path:\n                remotes = [r.strip() for r in remote_path.split(\",\")]\n                locals_ = [l.strip() for l in local_path.split(\",\")]\n                if len(remotes) != len(locals_):\n                    raise ValueError(\"debugRemotePath and debugLocalPath must have the same number of entries\")\n                mappings = list(zip(remotes, locals_))\n                pydevd_file_utils.setup_client_server_paths(mappings)\n\n            pydevd.settrace(\n                args.debugServer,\n                port=args.debugPort,\n                stdoutToServer=True,\n                stderrToServer=True,\n            )\n            print(\"Remote debugger attached.\")\n\n    def handle_args(self, args: Namespace) -&gt; bool:\n        \"\"\"\n        Handle parsed arguments. Intended to be overridden in subclasses.\n\n        Args:\n            args (Namespace): Parsed argument namespace.\n\n        Returns:\n            bool: True if argument was handled and no further processing is required.\n        \"\"\"\n        self.args = args\n        self.debug = args.debug\n        self.quiet = args.quiet\n        self.verbose = args.verbose\n        self.force = args.force\n        self.optional_debug(args)\n        if args.about:\n            print(self.program_version_message)\n            print(f\"see {self.version.doc_url}\")\n            webbrowser.open(self.version.doc_url)\n            return True\n\n        return False\n\n    def handle_exception(self, e: BaseException) -&gt; int:\n        \"\"\"\n        Handle exceptions occurring during execution.\n        Subclasses can override this to provide custom error handling.\n\n        Args:\n            e (BaseException): The exception that was raised.\n\n        Returns:\n            int: The exit code (1 for KeyboardInterrupt, 2 for other exceptions).\n        \"\"\"\n        exit_code = 0\n        if isinstance(e, KeyboardInterrupt):\n            exit_code = 1\n        else:\n            # Check self.debug or args.debug specifically for traceback logic\n            is_debug = self.debug or (self.args and getattr(self.args, \"debug\", False))\n\n            if is_debug:\n                traceback.print_exc()\n            else:\n                msg = f\"{self.version.name}: {e}\\n\"\n                sys.stderr.write(msg)\n            exit_code = 2\n        return exit_code\n\n    def run(self, argv=None) -&gt; int:\n        \"\"\"\n        Execute the command line logic.\n\n        Args:\n            argv (list): Optional command line arguments.\n\n        Returns:\n            int: Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.\n        \"\"\"\n        try:\n            args = self.parse_args(argv)\n            handled = self.handle_args(args)\n            exit_code = 0\n            if not handled:\n                exit_code = 0\n        except BaseException as e:\n            exit_code = self.handle_exception(e)\n        return exit_code\n\n    @classmethod\n    def main(cls, version: Any, argv=None) -&gt; int:\n        \"\"\"\n        Entry point for scripts using this command line interface.\n\n        Args:\n            version: Version metadata object passed to constructor.\n            argv (list): Optional command line arguments.\n\n        Returns:\n            int: Exit code from `run()`.\n        \"\"\"\n        instance = cls(version)\n        exit_code = instance.run(argv)\n        return exit_code\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.__init__","title":"<code>__init__(version, description=None)</code>","text":"<p>Initialize the BaseCmd instance.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Any</code> <p>An object with .name, .version, .description, and .doc_url attributes.</p> required <code>description</code> <code>str</code> <p>Optional CLI description. Defaults to version.description.</p> <code>None</code> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def __init__(self, version: Any, description: Optional[str] = None):\n    \"\"\"\n    Initialize the BaseCmd instance.\n\n    Args:\n        version: An object with .name, .version, .description, and .doc_url attributes.\n        description (str): Optional CLI description. Defaults to version.description.\n    \"\"\"\n    self.version = version\n    self.description = description or self.version.description\n    name = getattr(self.version, \"name\", \"\")\n    version = getattr(self.version, \"version\", \"\")\n    updated = getattr(self.version, \"updated\", \"\")\n    self.version_msg = f\"{name} {version} {updated}\".strip()\n    self.program_version_message = self.version_msg\n    self.debug = False\n    self.quiet = False\n    self.verbose = False\n    self.force = False\n    self.parser = None\n    self.exit_code = 0\n    self.args = None\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.add_arguments","title":"<code>add_arguments(parser)</code>","text":"<p>Add standard CLI arguments to the parser, sorted by long option name.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required Source code in <code>basemkit/base_cmd.py</code> <pre><code>def add_arguments(self, parser: ArgumentParser):\n    \"\"\"\n    Add standard CLI arguments to the parser, sorted by long option name.\n\n    Args:\n        parser (ArgumentParser): The parser to add arguments to.\n    \"\"\"\n    parser.add_argument(\"-a\", \"--about\", action=\"store_true\", help=\"show version info and open documentation\")\n    parser.add_argument(\"-d\", \"--debug\", action=\"store_true\", help=\"enable debug output\")\n    parser.add_argument(\n        \"--debugLocalPath\", help=\"remote debug Server path mapping - localPath - path on machine where python runs\"\n    )\n    parser.add_argument(\"--debugPort\", type=int, default=5678, help=\"remote debug Port [default: %(default)s]\")\n    parser.add_argument(\n        \"--debugRemotePath\", help=\"remote debug Server path mapping - remotePath - path on debug server\"\n    )\n    parser.add_argument(\"--debugServer\", help=\"remote debug Server\")\n    parser.add_argument(\"-f\", \"--force\", action=\"store_true\", help=\"force overwrite or unsafe actions\")\n    parser.add_argument(\"-q\", \"--quiet\", action=\"store_true\", help=\"suppress all output\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"increase output verbosity\")\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=self.program_version_message)\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.cmd_parse","title":"<code>cmd_parse(argv)</code>","text":"<p>delegate method</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def cmd_parse(self, argv: List[str]) -&gt; Namespace:\n    \"\"\"delegate method\"\"\"\n    args = self.parse_args(argv)\n    return args\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>Compatibility layer for legacy camelCase contract. Calls get_arg_parser with overridden description and version_msg.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg: str) -&gt; ArgumentParser:\n    \"\"\"\n    Compatibility layer for legacy camelCase contract.\n    Calls get_arg_parser with overridden description and version_msg.\n    \"\"\"\n    self.description = description\n    self.program_version_message = version_msg\n    parser = ArgumentParser(description=description, formatter_class=RawDescriptionHelpFormatter)\n    self.add_arguments(parser)\n    return parser\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.get_arg_parser","title":"<code>get_arg_parser()</code>","text":"<p>Create and configure the argument parser.</p> <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>The configured argument parser.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def get_arg_parser(self) -&gt; ArgumentParser:\n    \"\"\"\n    Create and configure the argument parser.\n\n    Returns:\n        ArgumentParser: The configured argument parser.\n    \"\"\"\n    parser = self.getArgParser(self.description, self.version_msg)\n    return parser\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.handle_args","title":"<code>handle_args(args)</code>","text":"<p>Handle parsed arguments. Intended to be overridden in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed argument namespace.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if argument was handled and no further processing is required.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def handle_args(self, args: Namespace) -&gt; bool:\n    \"\"\"\n    Handle parsed arguments. Intended to be overridden in subclasses.\n\n    Args:\n        args (Namespace): Parsed argument namespace.\n\n    Returns:\n        bool: True if argument was handled and no further processing is required.\n    \"\"\"\n    self.args = args\n    self.debug = args.debug\n    self.quiet = args.quiet\n    self.verbose = args.verbose\n    self.force = args.force\n    self.optional_debug(args)\n    if args.about:\n        print(self.program_version_message)\n        print(f\"see {self.version.doc_url}\")\n        webbrowser.open(self.version.doc_url)\n        return True\n\n    return False\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.handle_exception","title":"<code>handle_exception(e)</code>","text":"<p>Handle exceptions occurring during execution. Subclasses can override this to provide custom error handling.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>BaseException</code> <p>The exception that was raised.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The exit code (1 for KeyboardInterrupt, 2 for other exceptions).</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def handle_exception(self, e: BaseException) -&gt; int:\n    \"\"\"\n    Handle exceptions occurring during execution.\n    Subclasses can override this to provide custom error handling.\n\n    Args:\n        e (BaseException): The exception that was raised.\n\n    Returns:\n        int: The exit code (1 for KeyboardInterrupt, 2 for other exceptions).\n    \"\"\"\n    exit_code = 0\n    if isinstance(e, KeyboardInterrupt):\n        exit_code = 1\n    else:\n        # Check self.debug or args.debug specifically for traceback logic\n        is_debug = self.debug or (self.args and getattr(self.args, \"debug\", False))\n\n        if is_debug:\n            traceback.print_exc()\n        else:\n            msg = f\"{self.version.name}: {e}\\n\"\n            sys.stderr.write(msg)\n        exit_code = 2\n    return exit_code\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.main","title":"<code>main(version, argv=None)</code>  <code>classmethod</code>","text":"<p>Entry point for scripts using this command line interface.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Any</code> <p>Version metadata object passed to constructor.</p> required <code>argv</code> <code>list</code> <p>Optional command line arguments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code from <code>run()</code>.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>@classmethod\ndef main(cls, version: Any, argv=None) -&gt; int:\n    \"\"\"\n    Entry point for scripts using this command line interface.\n\n    Args:\n        version: Version metadata object passed to constructor.\n        argv (list): Optional command line arguments.\n\n    Returns:\n        int: Exit code from `run()`.\n    \"\"\"\n    instance = cls(version)\n    exit_code = instance.run(argv)\n    return exit_code\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.optional_debug","title":"<code>optional_debug(args)</code>","text":"<p>Optionally start pydevd remote debugging if debugServer is specified.</p> <p>see https://www.pydev.org/manual_adv_remote_debugger.html</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed CLI arguments</p> required Source code in <code>basemkit/base_cmd.py</code> <pre><code>def optional_debug(self, args: Namespace):\n    \"\"\"\n    Optionally start pydevd remote debugging if debugServer is specified.\n\n    see https://www.pydev.org/manual_adv_remote_debugger.html\n\n    Args:\n        args (Namespace): Parsed CLI arguments\n    \"\"\"\n    if args.debugServer:\n        import pydevd\n        import pydevd_file_utils\n\n        remote_path = args.debugRemotePath\n        local_path = args.debugLocalPath\n\n        # note the complexity of https://stackoverflow.com/a/41765551/1497139\n        # discussed in 2011\n        if remote_path and local_path:\n            remotes = [r.strip() for r in remote_path.split(\",\")]\n            locals_ = [l.strip() for l in local_path.split(\",\")]\n            if len(remotes) != len(locals_):\n                raise ValueError(\"debugRemotePath and debugLocalPath must have the same number of entries\")\n            mappings = list(zip(remotes, locals_))\n            pydevd_file_utils.setup_client_server_paths(mappings)\n\n        pydevd.settrace(\n            args.debugServer,\n            port=args.debugPort,\n            stdoutToServer=True,\n            stderrToServer=True,\n        )\n        print(\"Remote debugger attached.\")\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.parse_args","title":"<code>parse_args(argv=None)</code>","text":"<p>Parse command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list</code> <p>Optional list of command line arguments. Defaults to sys.argv.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Namespace</code> <code>Namespace</code> <p>Parsed argument values.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def parse_args(self, argv=None) -&gt; Namespace:\n    \"\"\"\n    Parse command line arguments.\n\n    Args:\n        argv (list): Optional list of command line arguments. Defaults to sys.argv.\n\n    Returns:\n        Namespace: Parsed argument values.\n    \"\"\"\n    if self.parser is None:\n        self.parser = self.get_arg_parser()\n    self.args = self.parser.parse_args(argv)\n    args = self.args\n    return args\n</code></pre>"},{"location":"#basemkit.base_cmd.BaseCmd.run","title":"<code>run(argv=None)</code>","text":"<p>Execute the command line logic.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list</code> <p>Optional command line arguments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.</p> Source code in <code>basemkit/base_cmd.py</code> <pre><code>def run(self, argv=None) -&gt; int:\n    \"\"\"\n    Execute the command line logic.\n\n    Args:\n        argv (list): Optional command line arguments.\n\n    Returns:\n        int: Exit code: 0 = OK, 1 = KeyboardInterrupt, 2 = Exception.\n    \"\"\"\n    try:\n        args = self.parse_args(argv)\n        handled = self.handle_args(args)\n        exit_code = 0\n        if not handled:\n            exit_code = 0\n    except BaseException as e:\n        exit_code = self.handle_exception(e)\n    return exit_code\n</code></pre>"},{"location":"#basemkit.basetest","title":"<code>basetest</code>","text":"<p>Created on 2021-08-19</p> <p>@author: wf</p>"},{"location":"#basemkit.basetest.Basetest","title":"<code>Basetest</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>base test case</p> Source code in <code>basemkit/basetest.py</code> <pre><code>class Basetest(unittest.TestCase):\n    \"\"\"\n    base test case\n    \"\"\"\n\n    def setUp(self, debug=False, profile=True):\n        \"\"\"\n        setUp test environment\n        \"\"\"\n        unittest.TestCase.setUp(self)\n        self.debug = debug\n        self.profile = profile\n        msg = f\"test {self._testMethodName}, debug={self.debug}\"\n        self.profiler = Profiler(msg, profile=self.profile)\n\n    def tearDown(self):\n        unittest.TestCase.tearDown(self)\n        self.profiler.time()\n\n    @staticmethod\n    def inPublicCI():\n        \"\"\"\n        are we running in a public Continuous Integration Environment?\n        \"\"\"\n        publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n        jenkins = \"JENKINS_HOME\" in os.environ\n        return publicCI or jenkins\n\n    @staticmethod\n    def isUser(name: str):\n        \"\"\"Checks if the system has the given name\"\"\"\n        return getpass.getuser() == name\n\n    @staticmethod\n    def timeout(seconds: float) -&gt; Callable:\n        \"\"\"\n        Decorator to enforce a timeout on test methods.\n\n        Args:\n            seconds (float): Timeout duration in seconds.\n\n        Returns:\n            Callable: A decorator that wraps a function and raises TimeoutError\n                      if it exceeds the allowed execution time.\n\n        Raises:\n            TimeoutError: If the wrapped function exceeds the timeout.\n            Exception: If the wrapped function raises any other exception.\n        \"\"\"\n\n        def decorator(func):\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                result = [None]\n                exception = [None]\n\n                def target():\n                    try:\n                        result[0] = func(*args, **kwargs)\n                    except Exception as e:\n                        exception[0] = e\n\n                thread = threading.Thread(target=target)\n                thread.start()\n                thread.join(seconds)\n\n                if thread.is_alive():\n                    raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n                if exception[0] is not None:\n                    raise exception[0]\n\n                return result[0]\n\n            return wrapper\n\n        return decorator\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.inPublicCI","title":"<code>inPublicCI()</code>  <code>staticmethod</code>","text":"<p>are we running in a public Continuous Integration Environment?</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef inPublicCI():\n    \"\"\"\n    are we running in a public Continuous Integration Environment?\n    \"\"\"\n    publicCI = getpass.getuser() in [\"travis\", \"runner\"]\n    jenkins = \"JENKINS_HOME\" in os.environ\n    return publicCI or jenkins\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.isUser","title":"<code>isUser(name)</code>  <code>staticmethod</code>","text":"<p>Checks if the system has the given name</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef isUser(name: str):\n    \"\"\"Checks if the system has the given name\"\"\"\n    return getpass.getuser() == name\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.setUp","title":"<code>setUp(debug=False, profile=True)</code>","text":"<p>setUp test environment</p> Source code in <code>basemkit/basetest.py</code> <pre><code>def setUp(self, debug=False, profile=True):\n    \"\"\"\n    setUp test environment\n    \"\"\"\n    unittest.TestCase.setUp(self)\n    self.debug = debug\n    self.profile = profile\n    msg = f\"test {self._testMethodName}, debug={self.debug}\"\n    self.profiler = Profiler(msg, profile=self.profile)\n</code></pre>"},{"location":"#basemkit.basetest.Basetest.timeout","title":"<code>timeout(seconds)</code>  <code>staticmethod</code>","text":"<p>Decorator to enforce a timeout on test methods.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timeout duration in seconds.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A decorator that wraps a function and raises TimeoutError       if it exceeds the allowed execution time.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the wrapped function exceeds the timeout.</p> <code>Exception</code> <p>If the wrapped function raises any other exception.</p> Source code in <code>basemkit/basetest.py</code> <pre><code>@staticmethod\ndef timeout(seconds: float) -&gt; Callable:\n    \"\"\"\n    Decorator to enforce a timeout on test methods.\n\n    Args:\n        seconds (float): Timeout duration in seconds.\n\n    Returns:\n        Callable: A decorator that wraps a function and raises TimeoutError\n                  if it exceeds the allowed execution time.\n\n    Raises:\n        TimeoutError: If the wrapped function exceeds the timeout.\n        Exception: If the wrapped function raises any other exception.\n    \"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            result = [None]\n            exception = [None]\n\n            def target():\n                try:\n                    result[0] = func(*args, **kwargs)\n                except Exception as e:\n                    exception[0] = e\n\n            thread = threading.Thread(target=target)\n            thread.start()\n            thread.join(seconds)\n\n            if thread.is_alive():\n                raise TimeoutError(f\"Test timed out after {seconds} seconds\")\n\n            if exception[0] is not None:\n                raise exception[0]\n\n            return result[0]\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"#basemkit.docker_util","title":"<code>docker_util</code>","text":"<p>Created on 2025-05-14</p> <p>@author: wf</p>"},{"location":"#basemkit.docker_util.DockerUtil","title":"<code>DockerUtil</code>","text":"<p>docker utilities</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>class DockerUtil:\n    \"\"\"\n    docker utilities\n    \"\"\"\n\n    def __init__(self, shell: Shell, container_name: str, log: Log, verbose: bool = False, debug: bool = False):\n        self.shell = shell\n        self.container_name = container_name\n        self.log = log\n        self.verbose = verbose\n        self.debug = debug\n\n    def handle_exception(self, context: str, ex: Exception):\n        \"\"\"\n        handle the given exception\n        \"\"\"\n        container_name = self.container_name\n        self.log.log(\"\u274c\", container_name, f\"Exception {context}: {ex}\")\n        if self.debug:\n            # extract exception type, and trace back\n            ex_type = type(ex)\n            ex_tb = ex.__traceback__\n            # print exception stack details\n            traceback.print_exception(ex_type, ex, ex_tb)\n\n    def patch_file(self, file_path: str, callback, push_back: bool = True):\n        \"\"\"\n        Copy a file from the container, apply a patch callback, and optionally copy it back.\n\n        Args:\n            file_path (str): Absolute path to the file inside the container.\n            callback (Callable[[str], None]): Function to apply changes to the local copy.\n            push_back (bool): If True, copy the modified file back to the container.\n        \"\"\"\n\n        with NamedTemporaryFile(delete=False) as tmp:\n            local_path = tmp.name\n\n        # Copy file from container\n        result = self.shell.run(\n            f\"docker cp {self.container_name}:{file_path} {local_path}\",\n            tee=self.debug,\n        )\n        if result.returncode != 0:\n            raise RuntimeError(f\"docker cp from {file_path} failed\")\n\n        # Apply patch callback\n        callback(local_path)\n\n        # Copy file back to container\n        if push_back:\n            result = self.shell.run(\n                f\"docker cp {local_path} {self.container_name}:{file_path}\",\n                tee=self.debug,\n            )\n            if result.returncode != 0:\n                raise RuntimeError(f\"docker cp back to {file_path} failed\")\n\n        # Clean up\n        try:\n            os.unlink(local_path)\n        except Exception:\n            pass\n\n    def line_patch(self, path: str, line_callback, title: str, msg: str):\n        \"\"\"\n        Patch a file in the container line-by-line via callback and check in using RCS.\n\n        Args:\n            path (str): Path to file inside container.\n            line_callback (Callable[[str], Tuple[str, bool]]): Function to patch a line. Returns (line, found).\n            title (str): What is being patched, used for error message.\n            msg (str): RCS check-in message.\n        \"\"\"\n\n        def patch_callback(local_path):\n            with open(local_path, \"r\") as f:\n                lines = f.readlines()\n            found = False\n            with open(local_path, \"w\") as f:\n                for line in lines:\n                    patched_line, was_found = line_callback(line)\n                    f.write(patched_line)\n                    found = found or was_found\n            if not found:\n                raise RuntimeError(f\"\u26a0\ufe0f  No matching line found for {title} in {path}\")\n\n        self.patch_file(path, patch_callback)\n        self.run(f\"\"\"ci -l -m\"{msg}\" {path}\"\"\")\n\n    def run_script(self, name: str, script_content: str, tee: bool = False, *args):\n        \"\"\"Run a script in the container with parameters\"\"\"\n        with NamedTemporaryFile(mode=\"w\", suffix=\".sh\", delete=False) as tmp:\n            tmp.write(script_content)\n            tmp_file = tmp.name\n\n        os.chmod(tmp_file, 0o755)\n\n        # Copy script to container\n        container_script_path = f\"/tmp/{name}.sh\"\n        self.run_local(f\"docker cp {tmp_file} {self.container_name}:{container_script_path}\")\n\n        # Execute script in container with args\n        args_str = \" \".join(args)\n        process = self.run_local(\n            cmd=f\"docker exec -i {self.container_name} bash {container_script_path} {args_str}\",\n            tee=tee,\n        )\n\n        # Clean up local temporary file\n        try:\n            os.unlink(tmp_file)\n        except Exception:\n            pass\n\n        return process\n\n    def run(self, command):\n        \"\"\"Run a command in the container\"\"\"\n        # use single quotes\n        cmd = f\"docker exec -i {self.container_name} bash -c '{command}'\"\n        return self.run_local(cmd)\n\n    def run_local(self, cmd: str, tee: bool = False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run a command with sourced profile\n\n        Args:\n            cmd: The command to run\n            tree: if true show stdout/stderr while running the command\n\n        Returns:\n            subprocess.CompletedProcess: The result of the command\n        \"\"\"\n        process = self.shell.run(cmd, tee=tee, debug=self.debug)\n        return process\n\n    def inspect(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieve full .State of the Docker container.\n\n        Returns:\n            dict: parsed .State structure or None on error\n        \"\"\"\n        inspect_dict = None\n        cmd = f'docker inspect -f \"{{{{json .State}}}}\" {self.container_name}'\n        result = self.shell.run(cmd, debug=self.debug)\n        if result.returncode == 0:\n            try:\n                json_text = result.stdout.strip()\n                inspect_dict = json.loads(json_text)\n            except Exception as ex:\n                if self.debug:\n                    print(f\"Failed to parse Docker state JSON: {ex}\")\n        return inspect_dict\n\n    def run_shell_command(self, command: str, success_msg: str = None, error_msg: str = None) -&gt; ShellResult:\n        \"\"\"\n        Helper function for running shell commands with consistent error handling.\n\n        Args:\n            command: Shell command to run\n            success_msg: Message to log on success\n            error_msg: Message to log on error\n\n        Returns:\n            shell_result: a shell result\n        \"\"\"\n        container_name = self.container_name\n        command_success = False\n        proc = None\n        try:\n            proc = self.shell.run(command, debug=self.debug, tee=self.verbose)\n            if proc.returncode == 0:\n                if success_msg:\n                    self.log.log(\"\u2705\", container_name, success_msg)\n                command_success = True\n            else:\n                error_detail = error_msg or f\"Command failed: {command}\"\n                if proc.stderr:\n                    error_detail += f\" - {proc.stderr}\"\n                self.log.log(\"\u274c\", container_name, error_detail)\n                command_success = False\n        except Exception as ex:\n            self.handle_exception(f\"command '{command}'\", ex)\n            command_success = False\n        shell_result = ShellResult(proc, command_success)\n        return shell_result\n\n    def docker_cmd(self, cmd: str, options: str = \"\", args: str = \"\") -&gt; str:\n        \"\"\"\n        create the given docker command with the given options\n        \"\"\"\n        container_name = \"\" if cmd == \"info\" else self.container_name\n        if options:\n            options = f\" {options}\"\n        if args:\n            args = f\" {args}\"\n        full_cmd = f\"docker {cmd}{options} {container_name}{args}\"\n        return full_cmd\n\n    def run_docker_cmd(self, cmd: str, options: str = \"\", args: str = \"\") -&gt; ShellResult:\n        \"\"\"\n        run the given docker commmand with the given options\n        \"\"\"\n        container_name = self.container_name\n        full_cmd = self.docker_cmd(cmd, options, args)\n        shell_result = self.run_shell_command(\n            full_cmd,\n            success_msg=f\"{cmd} container {container_name}\",\n            error_msg=f\"Failed to {cmd} container {container_name}\",\n        )\n        return shell_result\n\n    def logs(self) -&gt; ShellResult:\n        \"\"\"show the logs of the container\"\"\"\n        logs_result = self.run_docker_cmd(\"logs\")\n        return logs_result\n\n    def docker_info(self) -&gt; ShellResult:\n        \"\"\"\n        Check if Docker is responsive on the host system.\n        \"\"\"\n        info_result = self.run_docker_cmd(\"info\")\n        return info_result\n\n    def stop(self) -&gt; ShellResult:\n        \"\"\"stop the server container\"\"\"\n        stop_result = self.run_docker_cmd(\"stop\")\n        return stop_result\n\n    def rm(self) -&gt; ShellResult:\n        \"\"\"remove the server container.\"\"\"\n        rm_result = self.run_docker_cmd(\"rm\")\n        return rm_result\n\n    def bash(self) -&gt; bool:\n        \"\"\"bash into the server container.\"\"\"\n        bash_cmd = self.docker_cmd(\"exec\", \"-it\", \"/bin/bash\")\n        print(bash_cmd)\n        return True\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.bash","title":"<code>bash()</code>","text":"<p>bash into the server container.</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def bash(self) -&gt; bool:\n    \"\"\"bash into the server container.\"\"\"\n    bash_cmd = self.docker_cmd(\"exec\", \"-it\", \"/bin/bash\")\n    print(bash_cmd)\n    return True\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.docker_cmd","title":"<code>docker_cmd(cmd, options='', args='')</code>","text":"<p>create the given docker command with the given options</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def docker_cmd(self, cmd: str, options: str = \"\", args: str = \"\") -&gt; str:\n    \"\"\"\n    create the given docker command with the given options\n    \"\"\"\n    container_name = \"\" if cmd == \"info\" else self.container_name\n    if options:\n        options = f\" {options}\"\n    if args:\n        args = f\" {args}\"\n    full_cmd = f\"docker {cmd}{options} {container_name}{args}\"\n    return full_cmd\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.docker_info","title":"<code>docker_info()</code>","text":"<p>Check if Docker is responsive on the host system.</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def docker_info(self) -&gt; ShellResult:\n    \"\"\"\n    Check if Docker is responsive on the host system.\n    \"\"\"\n    info_result = self.run_docker_cmd(\"info\")\n    return info_result\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.handle_exception","title":"<code>handle_exception(context, ex)</code>","text":"<p>handle the given exception</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def handle_exception(self, context: str, ex: Exception):\n    \"\"\"\n    handle the given exception\n    \"\"\"\n    container_name = self.container_name\n    self.log.log(\"\u274c\", container_name, f\"Exception {context}: {ex}\")\n    if self.debug:\n        # extract exception type, and trace back\n        ex_type = type(ex)\n        ex_tb = ex.__traceback__\n        # print exception stack details\n        traceback.print_exception(ex_type, ex, ex_tb)\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.inspect","title":"<code>inspect()</code>","text":"<p>Retrieve full .State of the Docker container.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[Dict[str, Any]]</code> <p>parsed .State structure or None on error</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def inspect(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve full .State of the Docker container.\n\n    Returns:\n        dict: parsed .State structure or None on error\n    \"\"\"\n    inspect_dict = None\n    cmd = f'docker inspect -f \"{{{{json .State}}}}\" {self.container_name}'\n    result = self.shell.run(cmd, debug=self.debug)\n    if result.returncode == 0:\n        try:\n            json_text = result.stdout.strip()\n            inspect_dict = json.loads(json_text)\n        except Exception as ex:\n            if self.debug:\n                print(f\"Failed to parse Docker state JSON: {ex}\")\n    return inspect_dict\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.line_patch","title":"<code>line_patch(path, line_callback, title, msg)</code>","text":"<p>Patch a file in the container line-by-line via callback and check in using RCS.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to file inside container.</p> required <code>line_callback</code> <code>Callable[[str], Tuple[str, bool]]</code> <p>Function to patch a line. Returns (line, found).</p> required <code>title</code> <code>str</code> <p>What is being patched, used for error message.</p> required <code>msg</code> <code>str</code> <p>RCS check-in message.</p> required Source code in <code>basemkit/docker_util.py</code> <pre><code>def line_patch(self, path: str, line_callback, title: str, msg: str):\n    \"\"\"\n    Patch a file in the container line-by-line via callback and check in using RCS.\n\n    Args:\n        path (str): Path to file inside container.\n        line_callback (Callable[[str], Tuple[str, bool]]): Function to patch a line. Returns (line, found).\n        title (str): What is being patched, used for error message.\n        msg (str): RCS check-in message.\n    \"\"\"\n\n    def patch_callback(local_path):\n        with open(local_path, \"r\") as f:\n            lines = f.readlines()\n        found = False\n        with open(local_path, \"w\") as f:\n            for line in lines:\n                patched_line, was_found = line_callback(line)\n                f.write(patched_line)\n                found = found or was_found\n        if not found:\n            raise RuntimeError(f\"\u26a0\ufe0f  No matching line found for {title} in {path}\")\n\n    self.patch_file(path, patch_callback)\n    self.run(f\"\"\"ci -l -m\"{msg}\" {path}\"\"\")\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.logs","title":"<code>logs()</code>","text":"<p>show the logs of the container</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def logs(self) -&gt; ShellResult:\n    \"\"\"show the logs of the container\"\"\"\n    logs_result = self.run_docker_cmd(\"logs\")\n    return logs_result\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.patch_file","title":"<code>patch_file(file_path, callback, push_back=True)</code>","text":"<p>Copy a file from the container, apply a patch callback, and optionally copy it back.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute path to the file inside the container.</p> required <code>callback</code> <code>Callable[[str], None]</code> <p>Function to apply changes to the local copy.</p> required <code>push_back</code> <code>bool</code> <p>If True, copy the modified file back to the container.</p> <code>True</code> Source code in <code>basemkit/docker_util.py</code> <pre><code>def patch_file(self, file_path: str, callback, push_back: bool = True):\n    \"\"\"\n    Copy a file from the container, apply a patch callback, and optionally copy it back.\n\n    Args:\n        file_path (str): Absolute path to the file inside the container.\n        callback (Callable[[str], None]): Function to apply changes to the local copy.\n        push_back (bool): If True, copy the modified file back to the container.\n    \"\"\"\n\n    with NamedTemporaryFile(delete=False) as tmp:\n        local_path = tmp.name\n\n    # Copy file from container\n    result = self.shell.run(\n        f\"docker cp {self.container_name}:{file_path} {local_path}\",\n        tee=self.debug,\n    )\n    if result.returncode != 0:\n        raise RuntimeError(f\"docker cp from {file_path} failed\")\n\n    # Apply patch callback\n    callback(local_path)\n\n    # Copy file back to container\n    if push_back:\n        result = self.shell.run(\n            f\"docker cp {local_path} {self.container_name}:{file_path}\",\n            tee=self.debug,\n        )\n        if result.returncode != 0:\n            raise RuntimeError(f\"docker cp back to {file_path} failed\")\n\n    # Clean up\n    try:\n        os.unlink(local_path)\n    except Exception:\n        pass\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.rm","title":"<code>rm()</code>","text":"<p>remove the server container.</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def rm(self) -&gt; ShellResult:\n    \"\"\"remove the server container.\"\"\"\n    rm_result = self.run_docker_cmd(\"rm\")\n    return rm_result\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.run","title":"<code>run(command)</code>","text":"<p>Run a command in the container</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def run(self, command):\n    \"\"\"Run a command in the container\"\"\"\n    # use single quotes\n    cmd = f\"docker exec -i {self.container_name} bash -c '{command}'\"\n    return self.run_local(cmd)\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.run_docker_cmd","title":"<code>run_docker_cmd(cmd, options='', args='')</code>","text":"<p>run the given docker commmand with the given options</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def run_docker_cmd(self, cmd: str, options: str = \"\", args: str = \"\") -&gt; ShellResult:\n    \"\"\"\n    run the given docker commmand with the given options\n    \"\"\"\n    container_name = self.container_name\n    full_cmd = self.docker_cmd(cmd, options, args)\n    shell_result = self.run_shell_command(\n        full_cmd,\n        success_msg=f\"{cmd} container {container_name}\",\n        error_msg=f\"Failed to {cmd} container {container_name}\",\n    )\n    return shell_result\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.run_local","title":"<code>run_local(cmd, tee=False)</code>","text":"<p>Run a command with sourced profile</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>The command to run</p> required <code>tree</code> <p>if true show stdout/stderr while running the command</p> required <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the command</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def run_local(self, cmd: str, tee: bool = False) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Run a command with sourced profile\n\n    Args:\n        cmd: The command to run\n        tree: if true show stdout/stderr while running the command\n\n    Returns:\n        subprocess.CompletedProcess: The result of the command\n    \"\"\"\n    process = self.shell.run(cmd, tee=tee, debug=self.debug)\n    return process\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.run_script","title":"<code>run_script(name, script_content, tee=False, *args)</code>","text":"<p>Run a script in the container with parameters</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def run_script(self, name: str, script_content: str, tee: bool = False, *args):\n    \"\"\"Run a script in the container with parameters\"\"\"\n    with NamedTemporaryFile(mode=\"w\", suffix=\".sh\", delete=False) as tmp:\n        tmp.write(script_content)\n        tmp_file = tmp.name\n\n    os.chmod(tmp_file, 0o755)\n\n    # Copy script to container\n    container_script_path = f\"/tmp/{name}.sh\"\n    self.run_local(f\"docker cp {tmp_file} {self.container_name}:{container_script_path}\")\n\n    # Execute script in container with args\n    args_str = \" \".join(args)\n    process = self.run_local(\n        cmd=f\"docker exec -i {self.container_name} bash {container_script_path} {args_str}\",\n        tee=tee,\n    )\n\n    # Clean up local temporary file\n    try:\n        os.unlink(tmp_file)\n    except Exception:\n        pass\n\n    return process\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.run_shell_command","title":"<code>run_shell_command(command, success_msg=None, error_msg=None)</code>","text":"<p>Helper function for running shell commands with consistent error handling.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Shell command to run</p> required <code>success_msg</code> <code>str</code> <p>Message to log on success</p> <code>None</code> <code>error_msg</code> <code>str</code> <p>Message to log on error</p> <code>None</code> <p>Returns:</p> Name Type Description <code>shell_result</code> <code>ShellResult</code> <p>a shell result</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def run_shell_command(self, command: str, success_msg: str = None, error_msg: str = None) -&gt; ShellResult:\n    \"\"\"\n    Helper function for running shell commands with consistent error handling.\n\n    Args:\n        command: Shell command to run\n        success_msg: Message to log on success\n        error_msg: Message to log on error\n\n    Returns:\n        shell_result: a shell result\n    \"\"\"\n    container_name = self.container_name\n    command_success = False\n    proc = None\n    try:\n        proc = self.shell.run(command, debug=self.debug, tee=self.verbose)\n        if proc.returncode == 0:\n            if success_msg:\n                self.log.log(\"\u2705\", container_name, success_msg)\n            command_success = True\n        else:\n            error_detail = error_msg or f\"Command failed: {command}\"\n            if proc.stderr:\n                error_detail += f\" - {proc.stderr}\"\n            self.log.log(\"\u274c\", container_name, error_detail)\n            command_success = False\n    except Exception as ex:\n        self.handle_exception(f\"command '{command}'\", ex)\n        command_success = False\n    shell_result = ShellResult(proc, command_success)\n    return shell_result\n</code></pre>"},{"location":"#basemkit.docker_util.DockerUtil.stop","title":"<code>stop()</code>","text":"<p>stop the server container</p> Source code in <code>basemkit/docker_util.py</code> <pre><code>def stop(self) -&gt; ShellResult:\n    \"\"\"stop the server container\"\"\"\n    stop_result = self.run_docker_cmd(\"stop\")\n    return stop_result\n</code></pre>"},{"location":"#basemkit.persistent_log","title":"<code>persistent_log</code>","text":"<p>Created on 2024-10-04</p> <p>@author: wf</p>"},{"location":"#basemkit.persistent_log.Log","title":"<code>Log</code>","text":"<p>Wrapper for persistent logging.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>@lod_storable\nclass Log:\n    \"\"\"\n    Wrapper for persistent logging.\n    \"\"\"\n\n    entries: List[LogEntry] = field(default_factory=list)\n\n    def color_msg(self, color, msg):\n        \"\"\"Display a colored message\"\"\"\n        print(f\"{color}{msg}{END_COLOR}\")\n\n    def __post_init__(self):\n        \"\"\"\n        Initializes the log with level mappings and updates the level counts.\n        \"\"\"\n        self.do_log = True\n        self.do_print = False\n        self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n        self.level_names = {\n            logging.ERROR: \"error\",\n            logging.WARNING: \"warn\",\n            logging.INFO: \"info\",\n        }\n        self.update_level_counts()\n\n    def clear(self):\n        \"\"\"\n        Clears all log entries.\n        \"\"\"\n        self.entries = []\n        self.update_level_counts()\n\n    def update_level_counts(self):\n        \"\"\"\n        Updates the counts for each log level based on the existing entries.\n        \"\"\"\n        self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n        for entry in self.entries:\n            counter = self.get_counter(entry.level_name)\n            if counter is not None:\n                counter[entry.kind] += 1\n\n    def get_counter(self, level: str) -&gt; Counter:\n        \"\"\"\n        Returns the counter for the specified log level.\n        \"\"\"\n        return self.level_counts.get(level)\n\n    def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n        \"\"\"\n        Get a summary of the most common counts for the specified log level.\n\n        Args:\n            level (str): The log level name ('error', 'warn', 'info').\n            limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n        Returns:\n            Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n        \"\"\"\n        counter = self.get_counter(level)\n        if counter:\n            count = sum(counter.values())\n            most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n            summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n            return count, summary_msg\n        return 0, f\"No entries found for level: {level}\"\n\n    def log(self, icon: str, kind: str, msg: str):\n        \"\"\"\n        Log a message with the specified icon and kind.\n\n        Args:\n            icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n            kind (str): The category or type of the log message.\n            msg (str): The log message to record.\n        \"\"\"\n        level = self.levels.get(icon, logging.INFO)\n        level_name = self.level_names[level]\n        icon_msg = f\"{icon}:{msg}\"\n        log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n        self.entries.append(log_entry)\n\n        # Update level counts\n        self.level_counts[level_name][kind] += 1\n\n        if self.do_log:\n            logging.log(level, icon_msg)\n        if self.do_print:\n            print(icon_msg)\n\n    def dump(self):\n        \"\"\"\n        dump my entries\n        \"\"\"\n        for entry in self.entries:\n            print(entry.as_text())\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initializes the log with level mappings and updates the level counts.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initializes the log with level mappings and updates the level counts.\n    \"\"\"\n    self.do_log = True\n    self.do_print = False\n    self.levels = {\"\u274c\": logging.ERROR, \"\u26a0\ufe0f\": logging.WARNING, \"\u2705\": logging.INFO}\n    self.level_names = {\n        logging.ERROR: \"error\",\n        logging.WARNING: \"warn\",\n        logging.INFO: \"info\",\n    }\n    self.update_level_counts()\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.clear","title":"<code>clear()</code>","text":"<p>Clears all log entries.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears all log entries.\n    \"\"\"\n    self.entries = []\n    self.update_level_counts()\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.color_msg","title":"<code>color_msg(color, msg)</code>","text":"<p>Display a colored message</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def color_msg(self, color, msg):\n    \"\"\"Display a colored message\"\"\"\n    print(f\"{color}{msg}{END_COLOR}\")\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.dump","title":"<code>dump()</code>","text":"<p>dump my entries</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def dump(self):\n    \"\"\"\n    dump my entries\n    \"\"\"\n    for entry in self.entries:\n        print(entry.as_text())\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.get_counter","title":"<code>get_counter(level)</code>","text":"<p>Returns the counter for the specified log level.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def get_counter(self, level: str) -&gt; Counter:\n    \"\"\"\n    Returns the counter for the specified log level.\n    \"\"\"\n    return self.level_counts.get(level)\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.get_level_summary","title":"<code>get_level_summary(level, limit=7)</code>","text":"<p>Get a summary of the most common counts for the specified log level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>The log level name ('error', 'warn', 'info').</p> required <code>limit</code> <code>int</code> <p>The maximum number of most common entries to include in the summary (default is 7).</p> <code>7</code> <p>Returns:</p> Type Description <code>Tuple[int, str]</code> <p>Tuple[int, str]: A tuple containing the count of log entries and a summary message.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def get_level_summary(self, level: str, limit: int = 7) -&gt; Tuple[int, str]:\n    \"\"\"\n    Get a summary of the most common counts for the specified log level.\n\n    Args:\n        level (str): The log level name ('error', 'warn', 'info').\n        limit (int): The maximum number of most common entries to include in the summary (default is 7).\n\n    Returns:\n        Tuple[int, str]: A tuple containing the count of log entries and a summary message.\n    \"\"\"\n    counter = self.get_counter(level)\n    if counter:\n        count = sum(counter.values())\n        most_common_entries = dict(counter.most_common(limit))  # Get the top 'limit' entries\n        summary_msg = f\"{level.capitalize()} entries: {most_common_entries}\"\n        return count, summary_msg\n    return 0, f\"No entries found for level: {level}\"\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.log","title":"<code>log(icon, kind, msg)</code>","text":"<p>Log a message with the specified icon and kind.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>str</code> <p>The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').</p> required <code>kind</code> <code>str</code> <p>The category or type of the log message.</p> required <code>msg</code> <code>str</code> <p>The log message to record.</p> required Source code in <code>basemkit/persistent_log.py</code> <pre><code>def log(self, icon: str, kind: str, msg: str):\n    \"\"\"\n    Log a message with the specified icon and kind.\n\n    Args:\n        icon (str): The icon representing the log level ('\u274c', '\u26a0\ufe0f', '\u2705').\n        kind (str): The category or type of the log message.\n        msg (str): The log message to record.\n    \"\"\"\n    level = self.levels.get(icon, logging.INFO)\n    level_name = self.level_names[level]\n    icon_msg = f\"{icon}:{msg}\"\n    log_entry = LogEntry(msg=icon_msg, level_name=level_name, kind=kind)\n    self.entries.append(log_entry)\n\n    # Update level counts\n    self.level_counts[level_name][kind] += 1\n\n    if self.do_log:\n        logging.log(level, icon_msg)\n    if self.do_print:\n        print(icon_msg)\n</code></pre>"},{"location":"#basemkit.persistent_log.Log.update_level_counts","title":"<code>update_level_counts()</code>","text":"<p>Updates the counts for each log level based on the existing entries.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def update_level_counts(self):\n    \"\"\"\n    Updates the counts for each log level based on the existing entries.\n    \"\"\"\n    self.level_counts = {\"error\": Counter(), \"warn\": Counter(), \"info\": Counter()}\n    for entry in self.entries:\n        counter = self.get_counter(entry.level_name)\n        if counter is not None:\n            counter[entry.kind] += 1\n</code></pre>"},{"location":"#basemkit.persistent_log.LogEntry","title":"<code>LogEntry</code>","text":"<p>Represents a log entry with a message, kind, and log level name.</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>@lod_storable\nclass LogEntry:\n    \"\"\"\n    Represents a log entry with a message, kind, and log level name.\n    \"\"\"\n\n    msg: str\n    kind: str\n    level_name: str\n    timestamp: Optional[str] = None\n\n    def __post_init__(self):\n        if self.timestamp is None:\n            self.timestamp = datetime.now().isoformat()\n\n    def as_text(self) -&gt; str:\n        \"\"\"Return text representation of log entry with timestamp\"\"\"\n        text = f\"[{self.timestamp}] {self.msg}\"\n        return text\n\n    def as_html(self) -&gt; str:\n        \"\"\"Return HTML representation of log entry with appropriate styling\"\"\"\n        color = \"red\" if self.level_name == \"error\" else \"orange\" if self.level_name == \"warn\" else \"black\"\n        text = self.as_text()\n        markup = f'&lt;p style=\"color: {color};\"&gt;{text}&lt;/p&gt;'\n        return markup\n</code></pre>"},{"location":"#basemkit.persistent_log.LogEntry.as_html","title":"<code>as_html()</code>","text":"<p>Return HTML representation of log entry with appropriate styling</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def as_html(self) -&gt; str:\n    \"\"\"Return HTML representation of log entry with appropriate styling\"\"\"\n    color = \"red\" if self.level_name == \"error\" else \"orange\" if self.level_name == \"warn\" else \"black\"\n    text = self.as_text()\n    markup = f'&lt;p style=\"color: {color};\"&gt;{text}&lt;/p&gt;'\n    return markup\n</code></pre>"},{"location":"#basemkit.persistent_log.LogEntry.as_text","title":"<code>as_text()</code>","text":"<p>Return text representation of log entry with timestamp</p> Source code in <code>basemkit/persistent_log.py</code> <pre><code>def as_text(self) -&gt; str:\n    \"\"\"Return text representation of log entry with timestamp\"\"\"\n    text = f\"[{self.timestamp}] {self.msg}\"\n    return text\n</code></pre>"},{"location":"#basemkit.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#basemkit.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>basemkit/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg: str, profile=True, with_start: bool = True):\n        \"\"\"\n        Construct the profiler with the given message and flags.\n\n        Args:\n            msg (str): The message to show if profiling is active.\n            profile (bool): True if profiling messages should be shown.\n            with_start (bool): If True, show start message immediately.\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        if with_start:\n            self.start()\n\n    def start(self):\n        \"\"\"\n        start profiling\n        \"\"\"\n        self.starttime = time.time()\n        if self.profile:\n            print(f\"Starting {self.msg} ...\")\n\n    def time(self, extraMsg: str = \"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True, with_start=True)</code>","text":"<p>Construct the profiler with the given message and flags.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to show if profiling is active.</p> required <code>profile</code> <code>bool</code> <p>True if profiling messages should be shown.</p> <code>True</code> <code>with_start</code> <code>bool</code> <p>If True, show start message immediately.</p> <code>True</code> Source code in <code>basemkit/profiler.py</code> <pre><code>def __init__(self, msg: str, profile=True, with_start: bool = True):\n    \"\"\"\n    Construct the profiler with the given message and flags.\n\n    Args:\n        msg (str): The message to show if profiling is active.\n        profile (bool): True if profiling messages should be shown.\n        with_start (bool): If True, show start message immediately.\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    if with_start:\n        self.start()\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def start(self):\n    \"\"\"\n    start profiling\n    \"\"\"\n    self.starttime = time.time()\n    if self.profile:\n        print(f\"Starting {self.msg} ...\")\n</code></pre>"},{"location":"#basemkit.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>basemkit/profiler.py</code> <pre><code>def time(self, extraMsg: str = \"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#basemkit.shell","title":"<code>shell</code>","text":"<p>Created on 2025-05-14</p> <p>@author: wf</p>"},{"location":"#basemkit.shell.Shell","title":"<code>Shell</code>","text":"<p>Runs commands with environment from profile</p> Source code in <code>basemkit/shell.py</code> <pre><code>class Shell:\n    \"\"\"\n    Runs commands with environment from profile\n    \"\"\"\n\n    def __init__(self, profile: str = None, shell_path: str = None):\n        \"\"\"\n        Initialize shell with optional profile\n\n        Args:\n            profile: Path to profile file to source e.g. ~/.zprofile\n            shell_path: the shell_path e.g. /bin/zsh\n        \"\"\"\n        self.profile = profile\n        self.shell_path = shell_path\n        if self.shell_path is None:\n            self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n        self.shell_name = os.path.basename(self.shell_path)\n        self.source_op = \"source\"\n        if self.profile is None:\n            self.profile = self.find_profile()\n            if self.profile == \".profile\":\n                self.source_op = \".\"\n\n    def find_profile(self) -&gt; str:\n        \"\"\"\n        Find the appropriate profile file for the current shell\n\n        Searches for the profile file corresponding to the shell_name\n        in the user's home directory.\n\n        Returns:\n            str: Path to the profile file or None if not found\n        \"\"\"\n        profile = None\n        home = os.path.expanduser(\"~\")\n        # Try common profile files\n        profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n        if self.shell_name in profiles:\n            profile_name = profiles[self.shell_name]\n            path = os.path.join(home, profile_name)\n            if os.path.exists(path):\n                profile = path\n        return profile\n\n    @classmethod\n    def ofArgs(cls, args: Namespace) -&gt; \"Shell\":\n        \"\"\"\n        Create Shell from command line args\n\n        Args:\n            args: Arguments with optional profile\n\n        Returns:\n            Shell: Configured Shell\n        \"\"\"\n        # Use explicit profile or detect\n        profile = getattr(args, \"profile\", None)\n        shell = cls(profile=profile)\n        return shell\n\n    def run(self, cmd: str, text: bool = True, debug: bool = False, tee: bool = False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n\n    def proc_stats(\n        self,\n        title: str,\n        procs: Dict[Path, subprocess.CompletedProcess],\n        ignores: List[str] = [],\n    ):\n        \"\"\"\n        Show process statistics with checkmark/crossmark and success/failure summary.\n\n        Args:\n            title (str): A short title to label the output section.\n            procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n            ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n        \"\"\"\n        total = len(procs)\n        failures = 0\n        print(f\"\\n{total} {title}:\")\n        for idx, (path, result) in enumerate(procs.items(), start=1):\n            stderr = result.stderr or \"\"\n            stdout = result.stdout or \"\"\n            ignored = any(ignore in stderr for ignore in ignores)\n            has_error = (stderr and not ignored) or (\"Error\" in stdout)\n            if has_error:\n                symbol = \"\u274c\"\n                failures += 1\n            else:\n                symbol = \"\u2705\"\n            print(f\"{symbol} {idx}/{total}: {path.name}\")\n        percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n        print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#basemkit.shell.Shell.__init__","title":"<code>__init__(profile=None, shell_path=None)</code>","text":"<p>Initialize shell with optional profile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>str</code> <p>Path to profile file to source e.g. ~/.zprofile</p> <code>None</code> <code>shell_path</code> <code>str</code> <p>the shell_path e.g. /bin/zsh</p> <code>None</code> Source code in <code>basemkit/shell.py</code> <pre><code>def __init__(self, profile: str = None, shell_path: str = None):\n    \"\"\"\n    Initialize shell with optional profile\n\n    Args:\n        profile: Path to profile file to source e.g. ~/.zprofile\n        shell_path: the shell_path e.g. /bin/zsh\n    \"\"\"\n    self.profile = profile\n    self.shell_path = shell_path\n    if self.shell_path is None:\n        self.shell_path = os.environ.get(\"SHELL\", \"/bin/bash\")\n    self.shell_name = os.path.basename(self.shell_path)\n    self.source_op = \"source\"\n    if self.profile is None:\n        self.profile = self.find_profile()\n        if self.profile == \".profile\":\n            self.source_op = \".\"\n</code></pre>"},{"location":"#basemkit.shell.Shell.find_profile","title":"<code>find_profile()</code>","text":"<p>Find the appropriate profile file for the current shell</p> <p>Searches for the profile file corresponding to the shell_name in the user's home directory.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the profile file or None if not found</p> Source code in <code>basemkit/shell.py</code> <pre><code>def find_profile(self) -&gt; str:\n    \"\"\"\n    Find the appropriate profile file for the current shell\n\n    Searches for the profile file corresponding to the shell_name\n    in the user's home directory.\n\n    Returns:\n        str: Path to the profile file or None if not found\n    \"\"\"\n    profile = None\n    home = os.path.expanduser(\"~\")\n    # Try common profile files\n    profiles = {\"zsh\": \".zprofile\", \"bash\": \".bash_profile\", \"sh\": \".profile\"}\n    if self.shell_name in profiles:\n        profile_name = profiles[self.shell_name]\n        path = os.path.join(home, profile_name)\n        if os.path.exists(path):\n            profile = path\n    return profile\n</code></pre>"},{"location":"#basemkit.shell.Shell.ofArgs","title":"<code>ofArgs(args)</code>  <code>classmethod</code>","text":"<p>Create Shell from command line args</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Arguments with optional profile</p> required <p>Returns:</p> Name Type Description <code>Shell</code> <code>Shell</code> <p>Configured Shell</p> Source code in <code>basemkit/shell.py</code> <pre><code>@classmethod\ndef ofArgs(cls, args: Namespace) -&gt; \"Shell\":\n    \"\"\"\n    Create Shell from command line args\n\n    Args:\n        args: Arguments with optional profile\n\n    Returns:\n        Shell: Configured Shell\n    \"\"\"\n    # Use explicit profile or detect\n    profile = getattr(args, \"profile\", None)\n    shell = cls(profile=profile)\n    return shell\n</code></pre>"},{"location":"#basemkit.shell.Shell.proc_stats","title":"<code>proc_stats(title, procs, ignores=[])</code>","text":"<p>Show process statistics with checkmark/crossmark and success/failure summary.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>A short title to label the output section.</p> required <code>procs</code> <code>Dict[Path, CompletedProcess]</code> <p>Mapping of input files to their process results.</p> required <code>ignores</code> <code>List[str]</code> <p>List of substrings. If any is found in stderr, the error is ignored.</p> <code>[]</code> Source code in <code>basemkit/shell.py</code> <pre><code>def proc_stats(\n    self,\n    title: str,\n    procs: Dict[Path, subprocess.CompletedProcess],\n    ignores: List[str] = [],\n):\n    \"\"\"\n    Show process statistics with checkmark/crossmark and success/failure summary.\n\n    Args:\n        title (str): A short title to label the output section.\n        procs (Dict[Path, subprocess.CompletedProcess]): Mapping of input files to their process results.\n        ignores (List[str], optional): List of substrings. If any is found in stderr, the error is ignored.\n    \"\"\"\n    total = len(procs)\n    failures = 0\n    print(f\"\\n{total} {title}:\")\n    for idx, (path, result) in enumerate(procs.items(), start=1):\n        stderr = result.stderr or \"\"\n        stdout = result.stdout or \"\"\n        ignored = any(ignore in stderr for ignore in ignores)\n        has_error = (stderr and not ignored) or (\"Error\" in stdout)\n        if has_error:\n            symbol = \"\u274c\"\n            failures += 1\n        else:\n            symbol = \"\u2705\"\n        print(f\"{symbol} {idx}/{total}: {path.name}\")\n    percent_ok = ((total - failures) / total) * 100 if total &gt; 0 else 0\n    print(f\"\\n\u2705 {total - failures}/{total} ({percent_ok:.1f}%), \u274c {failures}/{total} ({100 - percent_ok:.1f}%)\")\n</code></pre>"},{"location":"#basemkit.shell.Shell.run","title":"<code>run(cmd, text=True, debug=False, tee=False)</code>","text":"<p>Run command with profile, always capturing output and optionally teeing it.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>Command to run</p> required <code>text</code> <code>bool</code> <p>Text mode for subprocess I/O</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Print the command to be run</p> <code>False</code> <code>tee</code> <code>bool</code> <p>If True, also print output live while capturing</p> <code>False</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess</p> Source code in <code>basemkit/shell.py</code> <pre><code>    def run(self, cmd: str, text: bool = True, debug: bool = False, tee: bool = False) -&gt; subprocess.CompletedProcess:\n        \"\"\"\n        Run command with profile, always capturing output and optionally teeing it.\n\n        Args:\n            cmd: Command to run\n            text: Text mode for subprocess I/O\n            debug: Print the command to be run\n            tee: If True, also print output live while capturing\n\n        Returns:\n            subprocess.CompletedProcess\n        \"\"\"\n        shell_cmd = f\"source {self.profile} &amp;&amp; {cmd}\" if self.profile else cmd\n\n        if debug:\n            print(f\"Running: {shell_cmd}\")\n\n        popen_process = subprocess.Popen(\n            [self.shell_path, \"-c\", shell_cmd],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=text,\n        )\n\n        std_tee = StdTee.run(popen_process, tee=tee)\n        returncode = popen_process.wait()\n\n        process = subprocess.CompletedProcess(\n            args=popen_process.args,\n            returncode=returncode,\n            stdout=std_tee.stdout_buffer.getvalue(),\n            stderr=std_tee.stderr_buffer.getvalue(),\n        )\n\n        if process.returncode != 0:\n            if debug:\n                msg = f\"\"\"{process.args} failed:\n  returncode: {process.returncode}\n  stdout    : {process.stdout.strip()}\n  stderr    : {process.stderr.strip()}\n\"\"\"\n                print(msg, file=sys.stderr)\n            pass\n\n        return process\n</code></pre>"},{"location":"#basemkit.shell.ShellResult","title":"<code>ShellResult</code>","text":"<p>result of a command line call</p> Source code in <code>basemkit/shell.py</code> <pre><code>class ShellResult:\n    \"\"\"\n    result of a command line call\n    \"\"\"\n\n    def __init__(self, proc, success: bool):\n        self.proc = proc\n        self.success = success\n\n    def __str__(self):\n        text = self.as_text()\n        return text\n\n    def as_text(self, debug: bool = False):\n        if debug:\n            text = f\"{self.proc.args} \u2192 rc={self.proc.returncode}, success={self.success}\"\n        else:\n            text = \"\u2705\" if self.success else f\"\u274c \u2192 rc={self.proc.returncode}\"\n        return text\n</code></pre>"},{"location":"#basemkit.shell.StdTee","title":"<code>StdTee</code>","text":"<p>Manages teeing for both stdout and stderr using StreamTee instances. Captures output in instance variables.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class StdTee:\n    \"\"\"\n    Manages teeing for both stdout and stderr using StreamTee instances.\n    Captures output in instance variables.\n    \"\"\"\n\n    def __init__(self, process, tee=True):\n        self.stdout_buffer = io.StringIO()\n        self.stderr_buffer = io.StringIO()\n        self.out_tee = StreamTee(process.stdout, sys.stdout, self.stdout_buffer, tee)\n        self.err_tee = StreamTee(process.stderr, sys.stderr, self.stderr_buffer, tee)\n\n    def start(self):\n        self.out_tee.start()\n        self.err_tee.start()\n\n    def join(self):\n        self.out_tee.join()\n        self.err_tee.join()\n\n    @classmethod\n    def run(cls, process, tee=True):\n        \"\"\"\n        Run teeing and capture for the given process.\n        Returns a StdTee instance with stdout/stderr captured.\n        \"\"\"\n        std_tee = cls(process, tee=tee)\n        std_tee.start()\n        std_tee.join()\n        return std_tee\n</code></pre>"},{"location":"#basemkit.shell.StdTee.run","title":"<code>run(process, tee=True)</code>  <code>classmethod</code>","text":"<p>Run teeing and capture for the given process. Returns a StdTee instance with stdout/stderr captured.</p> Source code in <code>basemkit/shell.py</code> <pre><code>@classmethod\ndef run(cls, process, tee=True):\n    \"\"\"\n    Run teeing and capture for the given process.\n    Returns a StdTee instance with stdout/stderr captured.\n    \"\"\"\n    std_tee = cls(process, tee=tee)\n    std_tee.start()\n    std_tee.join()\n    return std_tee\n</code></pre>"},{"location":"#basemkit.shell.StreamTee","title":"<code>StreamTee</code>","text":"<p>Tees a single input stream to both a mirror and a capture buffer.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class StreamTee:\n    \"\"\"\n    Tees a single input stream to both a mirror and a capture buffer.\n    \"\"\"\n\n    def __init__(self, source, mirror, buffer, tee=True):\n        self.source = source\n        self.mirror = mirror\n        self.buffer = buffer\n        self.tee = tee\n        self.thread = threading.Thread(target=self._run, daemon=True)\n\n    def _run(self):\n        for line in iter(self.source.readline, \"\"):\n            if self.tee:\n                self.mirror.write(line)\n                self.mirror.flush()\n            self.buffer.write(line)\n        self.source.close()\n\n    def start(self):\n        self.thread.start()\n\n    def join(self):\n        self.thread.join()\n</code></pre>"},{"location":"#basemkit.shell.SysTee","title":"<code>SysTee</code>","text":"<p>Tee sys.stdout and sys.stderr to a logfile while preserving original output.</p> Source code in <code>basemkit/shell.py</code> <pre><code>class SysTee:\n    \"\"\"\n    Tee sys.stdout and sys.stderr to a logfile while preserving original output.\n    \"\"\"\n\n    def __init__(self, log_path: str):\n        self.logfile = open(log_path, \"a\")\n        self.original_stdout = sys.stdout\n        self.original_stderr = sys.stderr\n        sys.stdout = self\n        sys.stderr = self\n\n    def write(self, data):\n        self.original_stdout.write(data)\n        self.logfile.write(data)\n\n    def flush(self):\n        self.original_stdout.flush()\n        self.logfile.flush()\n\n    def close(self):\n        sys.stdout = self.original_stdout\n        sys.stderr = self.original_stderr\n        self.logfile.close()\n</code></pre>"},{"location":"#basemkit.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.    Use 'samples 2' example from pyLoDStorage    https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference.</li> <li>Ensure tests cover YAML/JSON serialization, deserialization,    and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json     prerequisite behavior to a class</li> </ol>"},{"location":"#basemkit.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML stream.\n\n        Args:\n            stream (TextIO): The input stream containing YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = stream.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            return cls.load_from_yaml_stream(file)\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_stream(self, file: TextIO):\n        \"\"\"\n        Saves the current dataclass instance to the given YAML stream.\n\n        Args:\n            file (TextIO): The stream to which YAML content will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        file.write(yaml_content)\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            self.save_to_yaml_stream(file)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\", encoding=\"utf-8\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs: Any):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                    return False  # Empty list, set, tuple, etc., but not string or bytes\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        return cls.load_from_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_stream","title":"<code>load_from_yaml_stream(stream)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>TextIO</code> <p>The input stream containing YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_stream(cls: Type[T], stream: TextIO) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML stream.\n\n    Args:\n        stream (TextIO): The input stream containing YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = stream.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if isinstance(v, Iterable) and not isinstance(v, (str, bytes)) and not v:\n                return False  # Empty list, set, tuple, etc., but not string or bytes\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(v, ignore_none, ignore_underscore, ignore_empty)\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs: Any):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        self.save_to_yaml_stream(file)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.save_to_yaml_stream","title":"<code>save_to_yaml_stream(file)</code>","text":"<p>Saves the current dataclass instance to the given YAML stream.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>TextIO</code> <p>The stream to which YAML content will be saved.</p> required Source code in <code>basemkit/yamlable.py</code> <pre><code>def save_to_yaml_stream(self, file: TextIO):\n    \"\"\"\n    Saves the current dataclass instance to the given YAML stream.\n\n    Args:\n        file (TextIO): The stream to which YAML content will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    file.write(yaml_content)\n</code></pre>"},{"location":"#basemkit.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(obj_dict, ignore_none, ignore_underscore)\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#basemkit.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>basemkit/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    # Ensure the new class created by the decorator (LoDStorable)\n    # retains the identity of the original class (cls) for proper\n    # serialization and module lookup.\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n    LoDStorable.__module__ = cls.__module__\n\n    return LoDStorable\n</code></pre>"}]}